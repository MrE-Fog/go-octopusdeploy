// Code generated by go-enum
// DO NOT EDIT!

package enum

import (
	"fmt"
	"strings"
)

const (
	// NoCommunicationStyle is a CommunicationStyle of type NoCommunicationStyle
	NoCommunicationStyle CommunicationStyle = iota
	// TentaclePassive is a CommunicationStyle of type TentaclePassive
	TentaclePassive
	// TentacleActive is a CommunicationStyle of type TentacleActive
	TentacleActive
	// Ssh is a CommunicationStyle of type Ssh
	Ssh
	// OfflineDrop is a CommunicationStyle of type OfflineDrop
	OfflineDrop
	// AzureWebApp is a CommunicationStyle of type AzureWebApp
	AzureWebApp
	// Ftp is a CommunicationStyle of type Ftp
	Ftp
	// AzureCloudService is a CommunicationStyle of type AzureCloudService
	AzureCloudService
	// AzureServiceFabricCluster is a CommunicationStyle of type AzureServiceFabricCluster
	AzureServiceFabricCluster
	// Kubernetes is a CommunicationStyle of type Kubernetes
	Kubernetes
)

const _CommunicationStyleName = "NoCommunicationStyleTentaclePassiveTentacleActiveSshOfflineDropAzureWebAppFtpAzureCloudServiceAzureServiceFabricClusterKubernetes"

var _CommunicationStyleNames = []string{
	_CommunicationStyleName[0:20],
	_CommunicationStyleName[20:35],
	_CommunicationStyleName[35:49],
	_CommunicationStyleName[49:52],
	_CommunicationStyleName[52:63],
	_CommunicationStyleName[63:74],
	_CommunicationStyleName[74:77],
	_CommunicationStyleName[77:94],
	_CommunicationStyleName[94:119],
	_CommunicationStyleName[119:129],
}

// CommunicationStyleNames returns a list of possible string values of CommunicationStyle.
func CommunicationStyleNames() []string {
	tmp := make([]string, len(_CommunicationStyleNames))
	copy(tmp, _CommunicationStyleNames)
	return tmp
}

var _CommunicationStyleMap = map[CommunicationStyle]string{
	0: _CommunicationStyleName[0:20],
	1: _CommunicationStyleName[20:35],
	2: _CommunicationStyleName[35:49],
	3: _CommunicationStyleName[49:52],
	4: _CommunicationStyleName[52:63],
	5: _CommunicationStyleName[63:74],
	6: _CommunicationStyleName[74:77],
	7: _CommunicationStyleName[77:94],
	8: _CommunicationStyleName[94:119],
	9: _CommunicationStyleName[119:129],
}

// String implements the Stringer interface.
func (x CommunicationStyle) String() string {
	if str, ok := _CommunicationStyleMap[x]; ok {
		return str
	}
	return fmt.Sprintf("CommunicationStyle(%d)", x)
}

var _CommunicationStyleValue = map[string]CommunicationStyle{
	_CommunicationStyleName[0:20]:                     0,
	strings.ToLower(_CommunicationStyleName[0:20]):    0,
	_CommunicationStyleName[20:35]:                    1,
	strings.ToLower(_CommunicationStyleName[20:35]):   1,
	_CommunicationStyleName[35:49]:                    2,
	strings.ToLower(_CommunicationStyleName[35:49]):   2,
	_CommunicationStyleName[49:52]:                    3,
	strings.ToLower(_CommunicationStyleName[49:52]):   3,
	_CommunicationStyleName[52:63]:                    4,
	strings.ToLower(_CommunicationStyleName[52:63]):   4,
	_CommunicationStyleName[63:74]:                    5,
	strings.ToLower(_CommunicationStyleName[63:74]):   5,
	_CommunicationStyleName[74:77]:                    6,
	strings.ToLower(_CommunicationStyleName[74:77]):   6,
	_CommunicationStyleName[77:94]:                    7,
	strings.ToLower(_CommunicationStyleName[77:94]):   7,
	_CommunicationStyleName[94:119]:                   8,
	strings.ToLower(_CommunicationStyleName[94:119]):  8,
	_CommunicationStyleName[119:129]:                  9,
	strings.ToLower(_CommunicationStyleName[119:129]): 9,
}

// ParseCommunicationStyle attempts to convert a string to a CommunicationStyle
func ParseCommunicationStyle(name string) (CommunicationStyle, error) {
	if x, ok := _CommunicationStyleValue[name]; ok {
		return x, nil
	}
	return CommunicationStyle(0), fmt.Errorf("%s is not a valid CommunicationStyle, try [%s]", name, strings.Join(_CommunicationStyleNames, ", "))
}

// MarshalText implements the text marshaller method
func (x CommunicationStyle) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *CommunicationStyle) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseCommunicationStyle(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
