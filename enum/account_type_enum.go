// Code generated by go-enum
// DO NOT EDIT!

package enum

import (
	"fmt"
	"strings"
)

const (
	// NoAccountType is a AccountType of type NoAccountType
	NoAccountType AccountType = iota
	// UsernamePassword is a AccountType of type UsernamePassword
	UsernamePassword
	// SshKeyPair is a AccountType of type SshKeyPair
	SshKeyPair
	// AzureSubscription is a AccountType of type AzureSubscription
	AzureSubscription
	// AzureServicePrincipal is a AccountType of type AzureServicePrincipal
	AzureServicePrincipal
	// AmazonWebServicesAccount is a AccountType of type AmazonWebServicesAccount
	AmazonWebServicesAccount
	// AmazonWebServicesRoleAccount is a AccountType of type AmazonWebServicesRoleAccount
	AmazonWebServicesRoleAccount
	// Token is a AccountType of type Token
	Token
)

const _AccountTypeName = "NoAccountTypeUsernamePasswordSshKeyPairAzureSubscriptionAzureServicePrincipalAmazonWebServicesAccountAmazonWebServicesRoleAccountToken"

var _AccountTypeNames = []string{
	_AccountTypeName[0:13],
	_AccountTypeName[13:29],
	_AccountTypeName[29:39],
	_AccountTypeName[39:56],
	_AccountTypeName[56:77],
	_AccountTypeName[77:101],
	_AccountTypeName[101:129],
	_AccountTypeName[129:134],
}

// AccountTypeNames returns a list of possible string values of AccountType.
func AccountTypeNames() []string {
	tmp := make([]string, len(_AccountTypeNames))
	copy(tmp, _AccountTypeNames)
	return tmp
}

var _AccountTypeMap = map[AccountType]string{
	0: _AccountTypeName[0:13],
	1: _AccountTypeName[13:29],
	2: _AccountTypeName[29:39],
	3: _AccountTypeName[39:56],
	4: _AccountTypeName[56:77],
	5: _AccountTypeName[77:101],
	6: _AccountTypeName[101:129],
	7: _AccountTypeName[129:134],
}

// String implements the Stringer interface.
func (x AccountType) String() string {
	if str, ok := _AccountTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("AccountType(%d)", x)
}

var _AccountTypeValue = map[string]AccountType{
	_AccountTypeName[0:13]:                     0,
	strings.ToLower(_AccountTypeName[0:13]):    0,
	_AccountTypeName[13:29]:                    1,
	strings.ToLower(_AccountTypeName[13:29]):   1,
	_AccountTypeName[29:39]:                    2,
	strings.ToLower(_AccountTypeName[29:39]):   2,
	_AccountTypeName[39:56]:                    3,
	strings.ToLower(_AccountTypeName[39:56]):   3,
	_AccountTypeName[56:77]:                    4,
	strings.ToLower(_AccountTypeName[56:77]):   4,
	_AccountTypeName[77:101]:                   5,
	strings.ToLower(_AccountTypeName[77:101]):  5,
	_AccountTypeName[101:129]:                  6,
	strings.ToLower(_AccountTypeName[101:129]): 6,
	_AccountTypeName[129:134]:                  7,
	strings.ToLower(_AccountTypeName[129:134]): 7,
}

// ParseAccountType attempts to convert a string to a AccountType
func ParseAccountType(name string) (AccountType, error) {
	if x, ok := _AccountTypeValue[name]; ok {
		return x, nil
	}
	return AccountType(0), fmt.Errorf("%s is not a valid AccountType, try [%s]", name, strings.Join(_AccountTypeNames, ", "))
}

// MarshalText implements the text marshaller method
func (x AccountType) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method
func (x *AccountType) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseAccountType(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
